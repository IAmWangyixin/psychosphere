---
title: 引言
author: 山雨竹韵
date: '2023-10-10'
---

Lexical 是一个可扩展的 JavaScript Web 文本编辑器框架，强调可靠性、可访问性和性能。 Lexical 旨在提供一流的开发人员体验，以便您可以轻松地进行原型设计并充满信心地构建功能。 结合高度可扩展的架构，Lexical 允许开发人员创建可扩展大小和功能的独特文本编辑体验。

Lexical 的工作原理是将自身附加到 contentEditable 元素，从那里您可以使用 Lexical 的声明性 API 来实现事情的发生，而无需担心 DOM 周围的特定边缘情况。 事实上，在大多数情况下，您很少需要与 DOM 交互（除非您构建自己的自定义节点）。

Lexical 的核心包文件大小仅为 22kb (min+gzip)，您只需支付所需的费用。 因此 Lexical 可以随着您的表面和要求而发展。 此外，在支持延迟加载的框架中，您可以推迟 Lexical 插件，直到用户实际与编辑器本身交互——这可以极大地帮助提高性能。

## Lexical 可以构建什么？

Lexical 可以轻松创建复杂的文本编辑体验，否则使用内置浏览器工具会变得非常复杂。我们构建 Lexical 是为了让开发人员能够快速行动并创建可满足特定要求的不同类型的文本体验。 以下是一些（但不是全部）示例，说明您可以使用 Lexical 执行以下操作：

- 简单的纯文本编辑器比 `<textarea>` 有更多的要求，例如需要提及、自定义表情符号、链接和主题标签等功能。
- 更复杂的富文本编辑器，可用于在博客、社交媒体、消息应用程序上发布内容。
- 成熟的所见即所得编辑器，可在 CMS 或富内容编辑器中使用。
- 结合了上述许多要点的实时协作文本编辑体验。

您可以将 Lexical 视为文本编辑器 UI 框架。 虽然 Lexical 目前只能在网络上使用，但该团队还在尝试为其他平台构建 Lexical 的本机版本。 在 Meta，Lexical 每天为 Facebook、Workplace、Messenger、WhatsApp 和 Instagram 上的数亿用户提供网络文本编辑体验。

## Lexical 的设计

Lexical 的核心是一个无依赖的文本编辑器框架，允许开发人员构建强大、简单和复杂的编辑器界面。 Lexical 有几个值得探索的概念：

### 编辑器实例

编辑器实例是将所有内容连接在一起的核心。 您可以将可内容编辑的 DOM 元素附加到编辑器实例，还可以注册侦听器和命令。 最重要的是，编辑器允许更新其 `EditorState`。 您可以使用 `createEditor()` API 创建编辑器实例，但是在使用 `@lexical/react` 等框架绑定时通常不必担心，因为库已经为您处理好了。

### 编辑状态

编辑器状态是底层数据模型，代表您想要在 DOM 上显示的内容。 编辑器状态包含两部分：

- `lexical` 节点树
- `lexical` 选择对象

编辑器状态一旦创建就不可变，为了更新编辑器状态，您必须通过 `editor.update(() => {...})` 来执行此操作。 但是，您还可以使用节点转换或命令处理程序“挂钩”到现有更新，这些更新将作为现有更新工作流程的一部分进行调用，以防止更新的级联/瀑布式更新。 您可以使用 `editor.getEditorState()` 检索当前编辑器状态。

编辑器状态也可以完全序列化为 JSON，并且可以使用 `editor.parseEditorState()` 轻松序列化回编辑器。

### 编辑更新

当您想要更改编辑器状态中的某些内容时，必须通过更新 `editor.update(() => {...})` 来完成。 传递给更新调用的闭包很重要。 在这里，您拥有活动编辑器状态的完整“词汇”上下文，并且它公开了对底层编辑器状态节点树的访问。 我们提倡在这种情况下使用 $ 前缀的函数，因为它表示可以专门使用它们的地方。 尝试在更新之外使用它们将触发运行时错误并显示相应的错误。 对于熟悉 React Hooks 的人来说，您可以认为它们具有类似的功能（除了 $ 函数可以按任何顺序使用）。

### DOM 协调器

Lexical 有自己的 DOM 协调器，它采用一组编辑器状态（始终是“当前”和“待定”）并对它们应用“差异”。 然后，它使用此 diff 来仅更新 DOM 中需要更改的部分。 您可以将其视为一种虚拟 DOM，但 Lexical 能够跳过大部分比较工作，因为它知道给定更新中发生了哪些变化。 DOM 协调器采用性能优化，有利于内容可编辑的典型启发式方法，并且能够自动确保 LTR 和 RTL 语言的一致性。

### 监听器、节点转换和命令

除了调用更新之外，Lexical 完成的大部分工作都是通过侦听器、节点转换和命令完成的。 这些都源于编辑器，并以 register 为前缀。 另一个重要的特性是所有的注册方法都返回一个函数来轻松取消订阅它们。 例如，以下是您收听词法编辑器更新的方式：

```JAVASCRIPT
const unregisterListener = editor.registerUpdateListener(({editorState}) => {
  // An update has occurred!
  console.log(editorState);
});

// Ensure we remove the listener later!
unregisterListener();
```

命令是 Lexical 中用于将所有内容连接在一起的通信系统。 可以使用 `createCommand()` 创建自定义命令，并使用 `editor.dispatchCommand(command, Payload)` 分派到编辑器。 当按键被触发以及其他重要信号发生时，Lexical 会在内部调度命令。 还可以使用 `editor.registerCommand(handler,priority)` 处理命令，传入的命令按优先级通过所有处理程序传播，直到处理程序停止传播（与浏览器中的事件传播类似）。
